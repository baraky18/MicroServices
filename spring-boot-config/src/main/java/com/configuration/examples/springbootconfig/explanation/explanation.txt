we have several levels of configurations:
1. configuration inside a property file (like my.greeting in application.properties file)
   the downside of this is that every time I want to configure something inside, I need to unzip the application jar,
   add the changes to the property file, zip to a jar and deliver the jar - next points avoids that
2. configuration outside the jar. 
   a. I can go to C:\Users\baraky\git\MicroServices\spring-boot-config\target (where the jar is located)
   b. create another application.properties file in the same location
   c. add the same my.greeting property
   d. give it another value and 
   e. run the jar again
   the new property file outside the jat will override the changes
   made in the property file inside the jar
3. configuration using command line
   a. I can go to C:\Users\baraky\git\MicroServices\spring-boot-config\target (where the jar is located)
   b write the following command: java - jar spring-boot-config-0.0.1-SNAPSHOT.jar --my.greeting="Hello from command line"
   this will override even the second configuration
   
we can also change the properties file to a yml file.
this gives the opportunity to remove duplicate prefix of properties and show it in indentation.
the key principles in using ymls are:
1. all of the = turns to :
2. String property don't need "
3. if we have special chars in the property (like: {, }, /, ', *), we should put " at the beginning and in the end of the String
4. you have to indent the properties in order to tell yml that it's the same group of properties
5. when indenting don't use tabs only spaces

in order to make configuration more env specific we can use spring profiles.
spring profiles allows us to stuck configuration one on top of the other in a way that all of the common configuration
can be in the bottom layer and other layers can be env specific. few principles regarding this:
1. spring has a default profile that's actually the applucation.properties file
2. spring profiles can work with properties files and with yml files
3. we have several ways to define what is the active profile that we want:
   a. create a properties/ yml file in the same location as the existing one
   b. name the file application-<choosen name>.properties/ yml
   c. go to application.properties/ yml file and add the following property: spring.profiles.active: <choosen name>
   d. when running the jar in command line we can add an argument that overrides the above property and make in more env specific
4. we can have different beans instantiated by different configuration in order to trigger different business logic.
   this is done bu annotating the bean with @Profile("<chosen name>"). by default all of the other beans are internally 
   annotated with the @Profile("default") annotation
   
in order to externalize configuration, we can use configuration MS (spring-cloud-config-server). this MS will hold the configuration
in git repository files and will fetch them each and every time it is used. meaning, we don't have to boot the configuration server
for the changes to take place. it does that in several ways:
1. first, we have to define the MS as configuration client by adding a dependency of spring-cloud-starter-config and dependencyManagement
   in pom.xml of the MS.
2. we have to connect the MS to the configuration MS by adding spring.cloud.config.uri property to the application.yml file
3. we will create an application.yml in the git repository that will be common to all of the MS who uses this configuration MS
4. we will create a <spesific MS name>.yml in the git repository that will be specific to the MS that's using the configuration MS,
   we must add property spring.application.name to application.yml file that will specify the name of the client configuration MS

in order to manage the configuration in real time (without booting the client configuration server each time there's a change in configuration),
we have to do it in several steps:
1. add the dependency spring-boot-starter-actuator (if it's not already added) and add the property management.endpoints.web.exposure.include
   to the application.yml file.
2. add @RefreshScope to the file that we want to refresh each time there's a change in configuration.
3. we have to run <host>:<spesific MS port>/actuator/refresh POST method API